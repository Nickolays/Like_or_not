<h1 align="center">Like or not</h1>

Бинарная классификация для ваших песен на те что могут понравится и не понравится
____

В современном мире существует большое количество музыки и всю её прослушать не представляется возможным. Но что делать когда из всего этого многообразия хочется 
найти ту песню, которая может вам понравится. Для таких случаев пригодится файл audio.py. Он поможет вам не пропустить потенциально хорошие песни. Я думаю многие слышали о том
что для каждого человека существует свой, определённый набор звуков, которые ему нравятся.

Большой проблемой может показаться скачивание файлов, однако есть решение этой проблемы. Вот несколько ссылок для скачивания песен из интернета с помощью Python:
- [Скачать музыку с сайта](https://stackoverflow.com/questions/68808045/how-can-i-download-music-files-from-websites-using-python)
- [Скачать музыку с YouTube](https://www.geeksforgeeks.org/download-video-in-mp3-format-using-pytube/)
- [Скачать музыку с Spotify](https://habr.com/ru/post/582170/)
- [Смена формата mp3 на wav](https://www.geeksforgeeks.org/convert-mp3-to-wav-using-python/)

------

Я старался упроситить интерфейс для пользователя. На вход класс принимает 2 обязательных параметра (path_like, path_dlike) и 4 необязательных (start, duration, sample_rate, figsize).

```python
path_like = 'путь к песням, которые нравятся'
path_dlike = 'путь к файлам, которые не нравятся'
like_or_not = audio.Like_or_not(path_like, 
                                path_dlike, 
                                start=0,              # С какой секунды будут начинаться песни
                                duration=None,        # Длительность песни в секундах
                                sample_rate=22050,    # Частота дискретизации (сколько измерений делаем в секунду)
                                figsize=(16, 8),      # Размер картинки при сохранении изображений спектрограмм
                                )
```

В классе реализованны следующие методы:
- __show_libraries_version()__  - Покажет версии библиотек
- __get_name_song()__ - Получить pd.DataFrame с директорией, названем и таргетом для песен
- __get_X_y()__ - Получить признаки для бинарной классификации
- __save_img(_out_path=None, spec='stft'_)__ - Преобразовать и сохранить изображения спектрограмм (для LSTM и Conv2d). На выбор есть 5 типо спектрограмм
    - 'stft'
    - 'cqt'
    - 'mfcc'
    - 'chroma_stft'
    - 'chroma_cqt'

- __spec_Conv1D(_learning_rate=0.001_)__ - Модель Свёрточной 1D сети (анализ по времени). Если параметр duration=None, то отмасштабирует все треки к длине самого маленького
- __spec_Conv2D(_learning_rate=0.001, paht_with_imgs=None_)__ - Модель Свёрточной 2D сети (работа с фото). Можно не указаывать параметр duration у класса, так как все изображения сохраняются в одном размере
- __spec_LTSM(_learning_rate=0.001, paht_with_imgs=None_)__ - Модель рекурентной нейронной сети (принимает на вход изображение спектрограммы)
- __fit(_epochs=50, batch_size=5, n_splits=5, device='/cpu:0', patience=5, verbose=True_)__ - Обучение инициализированной модели
- __predict(_test_path: str, saved_model=None_)__ - Делает предсказание обученной модели или загруженной

### Примечания

> При вызове метода spec_Conv2D на вход будет подаваться массив (_batch_size, height_photo, width_photo, 1_), где 1 означает, что мы используем чёрно-белое изображение, а не
RGB (для экономии).

>> _height_photo_ - это ось x (время), 
>> _width_photo_ - это ось y(частота) и 
>> _значение пикселя_ - это амплитуда. 

> При вызове метода spec_LTSM, я бы рекомендовал использовать Характеристики Chroma (cqt, stft) или mfcc, потому что их можно представить в виде масивов формой (длинна изображения, 12 или 20), что сэкономит вычеслительные мощности в несколько раз.

> Если у вас уже есть сохранённые изображения спектрограмм, вы можете загрузить их для обучения модели в параметре (_paht_with_imgs='your_path_here'_) у методов _spec_Conv2D_ и _spec_LTSM_.

> Есть возможность загружать уже обученные модели, для этого в параметре (_saved_model_='путь к модели') у метода _predict_ укажите путь к ней.

Для более подробно ознакомления с функционалом, следует обратиться к файлу ['Examples']()
